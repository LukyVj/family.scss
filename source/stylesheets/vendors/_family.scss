// Argument mixin
//////////////////
@mixin first($num) {

  @if $num == 1 {
    &:first-child {
      @content;
    }
  }

  @else {
    &:nth-child(-n + #{$num}) {
      @content;
    }
  }
}

@mixin last($num) {
   &:nth-last-child(-n + #{$num}) {
    @content;
  }
}

@mixin after-first($num) {
  &:nth-child(n+#{$num + 1}) {
    @content
   }
}

@mixin from-end($num) {
  &:nth-last-child(#{$num}) {
   @content
  }
}

@mixin between($first,$last) {
  &:nth-child(n+#{$first}):nth-child(-n+#{$last}) {
    @content
  }
}

@mixin even-between($first,$last) {
  &:nth-child(even):nth-child(n + #{$first}):nth-child(-n + #{$last}) {
    @content
  }
}
@mixin odd-between($first,$last) {
  &:nth-child(odd):nth-child(n + #{$first}):nth-child(-n + #{$last}) {
    @content
  }
}
@mixin n-between($num,$first,$last) {
  &:nth-child(#{$num}n):nth-child(n + #{$first}):nth-child(-n + #{$last}) {
    @content
  }
}


@mixin all-but($num) {
  &:not(:nth-child(#{$num})) {
    @content
  }
}

@mixin each($num) {
  &:nth-child(#{$num}n) {
    @content
  }
}

// This mixin is commented because of a bug
// It has been removed for the v1.0.6
// @mixin each-after($num, $offset) {
//   @if $num < $offset {
//     &:nth-child(#{$offset - $num}n) ~ :nth-child(#{$num}n) {
//       @content;
//     }
//   }
// }

// Alias of each()
@mixin every($num) {
  @include each($num) {
    @content
  }
}

@mixin from-first-last($num) {
  &:nth-child(#{$num}),
  &:nth-last-child(#{$num}) {
    @content
  }
}


// impair only
@mixin middle($num) {
  &:nth-child(#{round($num/2)}){
    @content
  }
}


@mixin all-but-first-last($num) {
  &:nth-child(n+#{$num}):nth-last-child(n+#{$num}){
    @content
  }
}

// Quantity Queries
//////////////////

@mixin first-of($limit) {
  &:nth-last-child(#{$limit}):first-child {
   @content
  }
}

@mixin last-of($limit) {
  &:nth-of-type(#{$limit}):nth-last-of-type(1){
    @content
  }
}

@mixin at-least($num) {
    $selector: &;
    $child: nth(nth($selector, -1), -1);
    &:nth-last-child(n + #{$num}),
    &:nth-last-child(n + #{$num}) ~ #{$child} {
        @content;
    }
}

@mixin at-most($num) {
    $selector: &;
    $child: nth(nth($selector, -1), -1);
    &:nth-last-child(-n + #{$num}):first-child,
    &:nth-last-child(-n + #{$num}):first-child ~ #{$child} {
        @content;
    }
}

@mixin in-between($min, $max) {
    $selector: &;
    $child: nth(nth($selector, -1), -1);
    &:nth-last-child(n + #{$min}):nth-last-child(-n + #{$max}):first-child,
    &:nth-last-child(n + #{$min}):nth-last-child(-n + #{$max}):first-child ~ #{$child} {
      @content;
    }
}

// without arguments
//////////////////

@mixin first-child() {
  &:first-of-type {
    @content
  }
}

@mixin last-child() {
  &:last-of-type {
    @content
  }
}
@mixin even(){
  &:nth-child(even) {
    @content
  }
}

@mixin odd(){
  &:nth-child(odd) {
    @content
  }
}

@mixin first-last() {
  &:first-child,
  &:last-child {
    @content
  }
}

@mixin unique() {
  &:only-child {
    @content
  }
}

@mixin not-unique() {
  &:not(:only-child) {
    @content
  }
}
// Alias of unique()
@mixin only() {
  @include unique(){
    @content
  }
}


// Using functions
@mixin child-index($num, $direction: 'forward', $index: 0) {
  @for $i from 1 through $num {
    @if $direction == 'forward' {
      &:nth-child(#{$i}) {
      z-index: orderIndex($i, $index, $direction);
      @content;
    }

    }
  @if $direction == 'backward' {
      &:nth-last-child(#{$i}) {
        z-index: orderIndex($i, $index, $direction);
        @content;
      }
    }
  }
}



// Functions
@function orderIndex($i, $index, $direction){
  @if $direction == 'forward' {
    $i:$index + $i;
  }
  @else {
    $i:$index - $i;
  }
  @return $i
}
